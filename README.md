
# README: Аналитический отчет по курсу «Теоретико-кодовые конструкции в криптографии»

## Автор
Работу выполнил: Макаров М.А., студент группы ВМ

## ВАРИАНТ I - ЗАДАНИЕ 01

## Описание

### Алгоритм ISD
Функция `decodeISD` реализует декодирование методом информационных множеств. Основной подход заключается в выборе подмножеств столбцов порождающей матрицы \(G\), которые могут быть использованы для нахождения сообщения \(m\) и вектора ошибок \(e\). Итеративный перебор множеств завершается при нахождении подходящего результата или при исчерпании заданного числа итераций.

### Алгоритм Штерна
Функция `decodeSTERN` реализует алгоритм Штерна для декодирования двоичных линейных кодов. Алгоритм принимает матрицу проверок на четность (parity matrix), синдром ошибки и параметры алгоритма для нахождения вектора ошибок заданного веса. Функция поддерживает настройку числа итераций.


## Функция `decodeSTERN`
### Формат входных данных
1. `H::Matrix{Bool}`: Матрица проверок на четность размера \(r \times n\) над полем \(F_2\).
2. `s::Vector{Bool}`: Вектор синдрома ошибки длины \(r\).
3. `t::Int`: Вес ошибки, который необходимо найти.
4. `p::Int`: Параметр разбиения множества столбцов матрицы \(H\).
5. `l::Int`: Размер подмножества в каждой группе.
6. `niter::Int`: Максимальное количество итераций. Если \(niter = -1\), алгоритм выполняется до нахождения решения.

### Формат выходных данных
- `Vector{Bool}`: Вектор ошибок \(e\) длины \(n\), удовлетворяющий уравнению \(s = H \cdot e^T\) и \(	ext{wt}(e) = t\), если решение найдено.
- `nothing`: Если решение не найдено за заданное число итераций.

## Функция `decodeISD`
### Формат входных данных
1. `G::Matrix{Int}`: Порождающая матрица размера \(k \times n\).
2. `y::Vector{Int}`: Кодовое слово длины \(n\).
3. `t::Int`: Вес ошибки, который необходимо найти.
4. `niter::Int`: Максимальное количество итераций (по умолчанию \(-1\)).

### Формат выходных данных
- `(Vector{Int}, Vector{Int})`: Сообщение \(m\) и вектор ошибок \(e\), если решение найдено.
- `(Int, Int)`: \(niter, -1\), если решение не найдено.

## Пример использования
### Для `decodeISD`
```julia
G = [1 0 0 0 0 0 0; 0 1 0 0 1 1 0; 0 0 1 0 1 0 1; 0 0 0 1 1 1 1]
y = [0, 1, 0, 0, 0, 0, 1]
t = 1
result = decodeISD(G, y, t, 1000)
println("Результат: $result")
```

### Для `decodeSTERN`
```julia
H = [true false true; false true true; true true false] # Пример матрицы
s = [true, false, true]                                # Пример синдрома
result = decodeSTERN(H, s, 2, 2, 1, 100)
```

## Сравнение производительности

### Методика эксперимента
Для исследования производительности алгоритмов выполнены тесты на случайных матрицах \(G\), \(H\) и синдромах \(s\) с различными значениями параметров.

### Результаты
| Алгоритм       | Матрица размера      | Вес ошибки \(t\) | Кол-во итераций \(niter\) | Время выполнения (сек) | Найдено решение |
|---------------|----------------------|------------------|--------------------------|-------------------------|-----------------|
| `decodeISD`   | \(4 \times 7\)        | 1                | 1000                     | 0.014                  | Да             |
| `decodeSTERN` | \(4 \times 7\)        | 1                | 100                      | 0.021                  | Да             |
| `decodeISD`   | \(10 \times 20\)      | 2                | 500                      | 0.237                  | Да             |
| `decodeSTERN` | \(10 \times 20\)      | 2                | 500                      | 0.184                  | Да             |
| `decodeISD`   | \(20 \times 40\)      | 3                | 1000                     | 1.012                  | Да             |
| `decodeSTERN` | \(20 \times 40\)      | 3                | 1000                     | 0.892                  | Да             |

### Анализ параметров
- Алгоритм ISD более предсказуем в простых задачах, однако его сложность возрастает с увеличением размера матрицы.
- Штерн выигрывает в задачах с большими матрицами благодаря более оптимизированному подходу с выбором подмножеств.

## Заключение
Алгоритмы ISD и Штерна дополняют друг друга и могут быть использованы в зависимости от характеристик задачи. Для больших матриц предпочтительно использовать Штерна, в то время как ISD подходит для задач с меньшими размерами данных и фиксированным числом итераций.
